<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <title>Rust course</title>

  
  

  
    <link rel="stylesheet" href="https://mimuw-jnp2-rust.github.io/book.css">
  

  
  
</head>

<body>
<div class="menu">
  
  
  <nav role="navigation">
    <ul>
      <li><a href="https://mimuw-jnp2-rust.github.io">Home</a></li>
      
        
        
        
          
          <li >
            
            <a href="https:&#x2F;&#x2F;mimuw-jnp2-rust.github.io&#x2F;lessons&#x2F;">
              
              List of lessons
            </a>
            
              <ul>
                
                
                  
                  
                  
                    
                    
                  
                  
                    <li >
                      <a href="https:&#x2F;&#x2F;mimuw-jnp2-rust.github.io&#x2F;lessons&#x2F;00-organizational&#x2F;">
                        [2025-10-02]
                        
                        Organizational lesson
                      </a>
                    </li>
                  
                
                  
                  
                  
                    
                    
                  
                  
                    <li >
                      <a href="https:&#x2F;&#x2F;mimuw-jnp2-rust.github.io&#x2F;lessons&#x2F;01-introduction&#x2F;">
                        [2024-10-02]
                        
                        Introduction to Rust
                      </a>
                    </li>
                  
                
                  
                  
                  
                    
                    
                  
                  
                    <li >
                      <a href="https:&#x2F;&#x2F;mimuw-jnp2-rust.github.io&#x2F;lessons&#x2F;02-ownership&#x2F;">
                        [2025-10-09]
                        
                        Ownership Model
                      </a>
                    </li>
                  
                
                  
                  
                  
                    
                    
                  
                  
                    <li >
                      <a href="https:&#x2F;&#x2F;mimuw-jnp2-rust.github.io&#x2F;lessons&#x2F;03-data-types&#x2F;">
                        [2025-10-16]
                        
                        Data Types
                      </a>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2022-10-31]
                          
                          Feedback #1
                        </span>
                        <span class="upcoming-note">Available 2022-10-31</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                  
                  
                    <li  class="active" >
                      <a href="https:&#x2F;&#x2F;mimuw-jnp2-rust.github.io&#x2F;lessons&#x2F;05-types-reasoning&#x2F;">
                        [2025-10-23]
                        
                        Reasoning About Types
                      </a>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2029-01-01]
                          
                          Closures and Iterators
                        </span>
                        <span class="upcoming-note">Available 2029-01-01</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2029-01-01]
                          
                          Smart Pointers
                        </span>
                        <span class="upcoming-note">Available 2029-01-01</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2029-01-01]
                          
                          Feedback #2
                        </span>
                        <span class="upcoming-note">Available 2029-01-01</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2029-01-01]
                          
                          Fearless concurrency
                        </span>
                        <span class="upcoming-note">Available 2029-01-01</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2029-01-01]
                          
                          Design patterns
                        </span>
                        <span class="upcoming-note">Available 2029-01-01</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2029-01-01]
                          
                          Async: Part 1
                        </span>
                        <span class="upcoming-note">Available 2029-01-01</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2029-01-01]
                          
                          Project feedback
                        </span>
                        <span class="upcoming-note">Available 2029-01-01</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2029-01-01]
                          
                          Async: Part 2
                        </span>
                        <span class="upcoming-note">Available 2029-01-01</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2029-01-01]
                          
                          Macros
                        </span>
                        <span class="upcoming-note">Available 2029-01-01</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                      
                    
                  
                  
                    <li class="upcoming">
                      <span class="upcoming-content">
                        <span class="upcoming-title">
                          [2029-01-01]
                          
                          Unsafe Rust
                        </span>
                        <span class="upcoming-note">Available 2029-01-01</span>
                      </span>
                    </li>
                  
                
                  
                  
                  
                    
                    
                  
                  
                    <li >
                      <a href="https:&#x2F;&#x2F;mimuw-jnp2-rust.github.io&#x2F;lessons&#x2F;project-showcase&#x2F;">
                        [2022-10-17]
                        
                        2021L Project showcase
                      </a>
                    </li>
                  
                
                  
                  
                  
                    
                    
                  
                  
                    <li >
                      <a href="https:&#x2F;&#x2F;mimuw-jnp2-rust.github.io&#x2F;lessons&#x2F;table-of-contents&#x2F;">
                        [2025-10-05]
                        
                        Table of content
                      </a>
                    </li>
                  
                
              </ul>
            
          </li>
        
      
    </ul>
  </nav>
  
  
</div>

<div class="page">
  <div class="page-header">
    <div class="menu-icon">
      <span></span>
      <span></span>
      <span></span>
    </div>
    
      <span class="search-icon">🔎</span>
    
  </div>

  <div class="page__content">
    
      <div class="search-container">
        <input id="search" type="search" placeholder="Search..">
        <div class="search-results">
          <div class="search-results__header"></div>
          <ul class="search-results__items"></ul>
        </div>
      </div>
    
    <div class="book-content">
      
<h1 class="title">Reasoning About Types</h1>
<p class="subtitle">
  <strong>2025-10-23</strong> (last edit: 2025-10-20)
</p>
<h1 id="type-traits">Type traits</h1>
<p>Traits are a way to defined common behavior between different types. They can be compared to <em>interfaces</em> from many other mainstream languages or to type classes from Haskell, however, Rust is not an object-oriented language and there are some notable differences between type traits and Java interfaces.</p>
<p>The way we describe behavior in Rust is through methods. Traits consist of a set of these methods which then should be implemented by a type. We've already encountered examples of these, like the <code>Clone</code> trait which specified that the <code>clone()</code> method can be called on some given type. Now, let's take a deeper look and try defining our own trait.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#c82829;">allow</span><span>(dead_code)]
</span><span>
</span><span style="color:#8959a8;">trait </span><span>Summary {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; String;
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>NewsArticle {
</span><span>    </span><span style="color:#c82829;">headline</span><span>: String,
</span><span>    </span><span style="color:#c82829;">location</span><span>: String,
</span><span>    </span><span style="color:#c82829;">author</span><span>: String,
</span><span>    </span><span style="color:#c82829;">content</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Summary </span><span style="color:#8959a8;">for </span><span>NewsArticle {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; String {
</span><span>        format!(</span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">, by </span><span style="color:#666969;">{}</span><span style="color:#718c00;"> (</span><span style="color:#666969;">{}</span><span style="color:#718c00;">)&quot;</span><span>, </span><span style="color:#c82829;">self</span><span>.headline, </span><span style="color:#c82829;">self</span><span>.author, </span><span style="color:#c82829;">self</span><span>.location)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Tweet {
</span><span>    </span><span style="color:#c82829;">username</span><span>: String,
</span><span>    </span><span style="color:#c82829;">content</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Summary </span><span style="color:#8959a8;">for </span><span>Tweet {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; String {
</span><span>        format!(</span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, </span><span style="color:#c82829;">self</span><span>.username, </span><span style="color:#c82829;">self</span><span>.content)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> tweet </span><span style="color:#3e999f;">=</span><span> Tweet {
</span><span>        username: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;horse_ebooks&quot;</span><span>),
</span><span>        content: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;of course, as you probably already know, people&quot;</span><span>),
</span><span>    };
</span><span>
</span><span>    println!(</span><span style="color:#718c00;">&quot;1 new tweet: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, tweet.</span><span style="color:#4271ae;">summarize</span><span>());
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/basic_trait.rs">basic_trait.rs</a>)</sub></p>
<h2 id="default-implementations">Default implementations</h2>
<p>Trait definitions can also be provided with default implementations of behaviors.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#c82829;">allow</span><span>(dead_code)]
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Upload {
</span><span>    </span><span style="color:#c82829;">filename</span><span>: String,
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#c82829;">allow</span><span>(dead_code)]
</span><span style="color:#8959a8;">struct </span><span>Photo {
</span><span>    </span><span style="color:#c82829;">filename</span><span>: String,
</span><span>    </span><span style="color:#c82829;">width</span><span>: </span><span style="color:#8959a8;">u32</span><span>,
</span><span>    </span><span style="color:#c82829;">height</span><span>: </span><span style="color:#8959a8;">u32</span><span>,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">trait </span><span>Description {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">describe</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; String {
</span><span>        </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;No description available.&quot;</span><span>)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#999999;">// All default implementations
</span><span style="color:#8959a8;">impl </span><span>Description </span><span style="color:#8959a8;">for </span><span>Upload {}
</span><span>
</span><span style="color:#999999;">// Default implementations can be overwritten
</span><span style="color:#8959a8;">impl </span><span>Description </span><span style="color:#8959a8;">for </span><span>Photo {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">describe</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; String {
</span><span>        format!(</span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;"> (</span><span style="color:#666969;">{}</span><span style="color:#718c00;"> x </span><span style="color:#666969;">{}</span><span style="color:#718c00;">)&quot;</span><span>, </span><span style="color:#c82829;">self</span><span>.filename, </span><span style="color:#c82829;">self</span><span>.width, </span><span style="color:#c82829;">self</span><span>.height)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#999999;">// Default implementations can rely on methods with no defaults
</span><span style="color:#8959a8;">trait </span><span>Size {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">width</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#8959a8;">u32</span><span>;
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">height</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#8959a8;">u32</span><span>;
</span><span>
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">size</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#8959a8;">u32 </span><span>{
</span><span>        </span><span style="color:#c82829;">self</span><span>.</span><span style="color:#4271ae;">width</span><span>() </span><span style="color:#3e999f;">* </span><span style="color:#c82829;">self</span><span>.</span><span style="color:#4271ae;">height</span><span>()
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Size </span><span style="color:#8959a8;">for </span><span>Photo {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">width</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#8959a8;">u32 </span><span>{
</span><span>        </span><span style="color:#c82829;">self</span><span>.width
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">height</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#8959a8;">u32 </span><span>{
</span><span>        </span><span style="color:#c82829;">self</span><span>.height
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#999999;">// Using default impl of `size()`
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> upload </span><span style="color:#3e999f;">=</span><span> Upload {
</span><span>        filename: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;notes.txt&quot;</span><span>),
</span><span>    };
</span><span>
</span><span>    println!(</span><span style="color:#718c00;">&quot;Upload: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, upload.</span><span style="color:#4271ae;">describe</span><span>());
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> photo </span><span style="color:#3e999f;">=</span><span> Photo {
</span><span>        filename: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;stock_crustacean.png&quot;</span><span>),
</span><span>        width: </span><span style="color:#f5871f;">100</span><span>,
</span><span>        height: </span><span style="color:#f5871f;">150</span><span>,
</span><span>    };
</span><span>
</span><span>    println!(</span><span style="color:#718c00;">&quot;Photo: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, photo.</span><span style="color:#4271ae;">describe</span><span>());
</span><span>    println!(</span><span style="color:#718c00;">&quot;Size: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, photo.</span><span style="color:#4271ae;">size</span><span>());
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/trait_default.rs">trait_default.rs</a>)</sub></p>
<h2 id="what-about-derive">What about <em>derive</em>?</h2>
<p>There is a trait-related feature we have used quite extensively but not explained yet, namely the <code>#[derive]</code> attribute. When placed above a struct or enum, it tells the compiler to generate an implementation of certain traits automatically. For example, <code>#[derive(Debug)]</code> will cause the compiler to create the necessary <code>impl Debug for YourType { ... }</code> code behind the scenes, so that your type can be printed with <code>{:?}</code> in <code>println!</code>.</p>
<p>We'll learn about how to make it work with our own traits in the next lessons. For now, you can think of <code>derive</code> as a kind of code generator built into the compiler, which is especially useful when the implementation of a trait can be generalized for any type.</p>
<p>Below you can find a list of derivable traits from the standard library.</p>
<ul>
<li>
<p>Equality traits: <code>Eq</code>, <code>PartialEq</code> and comparison traits: <code>Ord</code> and <code>PartialOrd</code>. The <code>Partial-</code> versions exist because there are types which don't fulfill the reflexivity requirement of equality (<code>NaN != NaN</code>) or do not form a total order (<code> NaN &lt; 0.0 == false</code> and <code>NaN &gt;= 0.0 == false</code>).</p>
</li>
<li>
<p>Data duplication traits: <code>Clone</code> and <code>Copy</code></p>
</li>
<li>
<p><code>Hash</code> - allows using values of that type as keys in a hashmap</p>
</li>
<li>
<p><code>Default</code> - provides a zero-arg constructor function</p>
</li>
<li>
<p><code>Debug</code> - provides a formatting of the value which can be used in debugging context. Because the <code>derive</code> attribute automatically implements a pretty way of formatting, it is discouraged to implement this trait manually. In general, if it's possible to derive the <code>Debug</code>, there are no reasons against doing it.</p>
</li>
</ul>
<h3 id="when-is-it-possible-to-derive-a-trait">When is it possible to derive a trait?</h3>
<p>When all fields of a struct/variants of an enum implement that trait.</p>
<h3 id="should-all-traits-always-be-derived-if-it-is-possible">Should all traits always be derived if it is possible?</h3>
<p>No. Although it may be tempting to just slap <code>#[derive(Clone, Copy)]</code> everywhere, it would be counter-effective. For example, at some later point you might add a non-<code>Copy</code> field to the struct and your (or, what's worse, someone else's!) code would break. Another example: it makes little sense to use containers as keys in hashmaps or to compare tweets.</p>
<h1 id="generics">Generics</h1>
<p>Suppose we want to find the largest element in a sequence and return it. Very much on purpose, we didn't specify what type these elements would be - ideally, we would love it to work on all types that have a defined notion of a <em>largest</em> element. However, to make things simpler for now, let's focus only on two primitive types: <code>i32</code> and <code>char</code>. Let's try to write the code:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">largest_i32</span><span>(</span><span style="color:#f5871f;">list</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>[</span><span style="color:#8959a8;">i32</span><span>]) -&gt; </span><span style="color:#8959a8;">i32 </span><span>{
</span><span>    </span><span style="color:#8959a8;">let mut</span><span> largest </span><span style="color:#3e999f;">=</span><span> list[</span><span style="color:#f5871f;">0</span><span>];
</span><span>
</span><span>    </span><span style="color:#8959a8;">for </span><span style="color:#3e999f;">&amp;</span><span>item </span><span style="color:#3e999f;">in</span><span> list {
</span><span>        </span><span style="color:#8959a8;">if</span><span> item </span><span style="color:#3e999f;">&gt;</span><span> largest {
</span><span>            largest </span><span style="color:#3e999f;">=</span><span> item;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    largest
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">largest_char</span><span>(</span><span style="color:#f5871f;">list</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>[</span><span style="color:#8959a8;">char</span><span>]) -&gt; </span><span style="color:#8959a8;">char </span><span>{
</span><span>    </span><span style="color:#8959a8;">let mut</span><span> largest </span><span style="color:#3e999f;">=</span><span> list[</span><span style="color:#f5871f;">0</span><span>];
</span><span>
</span><span>    </span><span style="color:#8959a8;">for </span><span style="color:#3e999f;">&amp;</span><span>item </span><span style="color:#3e999f;">in</span><span> list {
</span><span>        </span><span style="color:#8959a8;">if</span><span> item </span><span style="color:#3e999f;">&gt;</span><span> largest {
</span><span>            largest </span><span style="color:#3e999f;">=</span><span> item;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    largest
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> number_list </span><span style="color:#3e999f;">= </span><span>vec![</span><span style="color:#f5871f;">34</span><span>, </span><span style="color:#f5871f;">50</span><span>, </span><span style="color:#f5871f;">25</span><span>, </span><span style="color:#f5871f;">100</span><span>, </span><span style="color:#f5871f;">65</span><span>];
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> result </span><span style="color:#3e999f;">= </span><span style="color:#4271ae;">largest_i32</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>number_list);
</span><span>    println!(</span><span style="color:#718c00;">&quot;The largest number is </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, result);
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> char_list </span><span style="color:#3e999f;">= </span><span>vec![</span><span style="color:#718c00;">&#39;y&#39;</span><span>, </span><span style="color:#718c00;">&#39;m&#39;</span><span>, </span><span style="color:#718c00;">&#39;a&#39;</span><span>, </span><span style="color:#718c00;">&#39;q&#39;</span><span>];
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> result </span><span style="color:#3e999f;">= </span><span style="color:#4271ae;">largest_char</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>char_list);
</span><span>    println!(</span><span style="color:#718c00;">&quot;The largest char is </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, result);
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/non_generic.rs">non_generic.rs</a>)</sub></p>
<p>Perfect, it works! Now only twenty more types to go...</p>
<p>Of course, Rust gives us a way to avoid all this code duplication and generalize the types we're working on.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">largest</span><span>&lt;T&gt;(</span><span style="color:#f5871f;">list</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>[T]) -&gt; T {
</span><span>    </span><span style="color:#8959a8;">let mut</span><span> largest </span><span style="color:#3e999f;">=</span><span> list[</span><span style="color:#f5871f;">0</span><span>];
</span><span>
</span><span>    </span><span style="color:#8959a8;">for </span><span style="color:#3e999f;">&amp;</span><span>item </span><span style="color:#3e999f;">in</span><span> list {
</span><span>        </span><span style="color:#8959a8;">if</span><span> item </span><span style="color:#3e999f;">&gt;</span><span> largest {
</span><span>            largest </span><span style="color:#3e999f;">=</span><span> item;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    largest
</span><span>}
</span></code></pre>
<p>Cleaner already - we merged possibly very many implementations into one. But, when we try to compile this:</p>
<pre style="background-color:#ffffff;color:#4d4d4c;"><code><span>error[E0369]: binary operation `&gt;` cannot be applied to type `T`
</span><span> --&gt; src/main.rs:5:17
</span><span>  |
</span><span>5 |         if item &gt; largest {
</span><span>  |            ---- ^ ------- T
</span><span>  |            |
</span><span>  |            T
</span><span>  |
</span><span>help: consider restricting type parameter `T`
</span><span>  |
</span><span>1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</span><span>  |             ++++++++++++++++++++++
</span></code></pre>
<p>Since <code>T</code> can be of absolutely any type now, the compiler cannot be sure that operator <code>&gt;</code> is defined. This aligns with what we wanted, as without comparing elements we don't have a notion of the largest one either. As always, the compiler messages come to our aid:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">largest</span><span>&lt;T: </span><span style="color:#c99e00;">PartialOrd</span><span>&gt;(</span><span style="color:#f5871f;">list</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>[T]) -&gt; T {
</span><span>    </span><span style="color:#8959a8;">let mut</span><span> largest </span><span style="color:#3e999f;">=</span><span> list[</span><span style="color:#f5871f;">0</span><span>];
</span><span>
</span><span>    </span><span style="color:#8959a8;">for </span><span style="color:#3e999f;">&amp;</span><span>item </span><span style="color:#3e999f;">in</span><span> list {
</span><span>        </span><span style="color:#8959a8;">if</span><span> item </span><span style="color:#3e999f;">&gt;</span><span> largest {
</span><span>            largest </span><span style="color:#3e999f;">=</span><span> item;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    largest
</span><span>}
</span></code></pre>
<p>We call this a <em>trait bound</em>, a way to provide constraints on what kind of types we are talking about in a given context. This implementation almost works now. Let's look at the new error.</p>
<pre style="background-color:#ffffff;color:#4d4d4c;"><code><span>error[E0508]: cannot move out of type `[T]`, a non-copy slice
</span><span> --&gt; src/main.rs:2:23
</span><span>  |
</span><span>2 |     let mut largest = list[0];
</span><span>  |                       ^^^^^^^
</span><span>  |                       |
</span><span>  |                       cannot move out of here
</span><span>  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
</span><span>  |                       help: consider borrowing here: `&amp;list[0]`
</span><span>
</span><span>error[E0507]: cannot move out of a shared reference
</span><span> --&gt; src/main.rs:4:18
</span><span>  |
</span><span>4 |     for &amp;item in list {
</span><span>  |         -----    ^^^^
</span><span>  |         ||
</span><span>  |         |data moved here
</span><span>  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
</span><span>  |         help: consider removing the `&amp;`: `item`
</span></code></pre>
<p>Our function attempts to take ownership, but, again, the compiler doesn't know whether <code>T</code> can just be trivially copied. Rust allows us to combine multiple trait bounds together:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">largest</span><span>&lt;T: </span><span style="color:#c99e00;">PartialOrd </span><span style="color:#3e999f;">+ </span><span style="color:#c99e00;">Copy</span><span>&gt;(</span><span style="color:#f5871f;">list</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>[T]) -&gt; T {
</span><span>    </span><span style="color:#8959a8;">let mut</span><span> largest </span><span style="color:#3e999f;">=</span><span> list[</span><span style="color:#f5871f;">0</span><span>];
</span><span>
</span><span>    </span><span style="color:#8959a8;">for </span><span style="color:#3e999f;">&amp;</span><span>item </span><span style="color:#3e999f;">in</span><span> list {
</span><span>        </span><span style="color:#8959a8;">if</span><span> item </span><span style="color:#3e999f;">&gt;</span><span> largest {
</span><span>            largest </span><span style="color:#3e999f;">=</span><span> item;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    largest
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> number_list </span><span style="color:#3e999f;">= </span><span>vec![</span><span style="color:#f5871f;">34</span><span>, </span><span style="color:#f5871f;">50</span><span>, </span><span style="color:#f5871f;">25</span><span>, </span><span style="color:#f5871f;">100</span><span>, </span><span style="color:#f5871f;">65</span><span>];
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> result </span><span style="color:#3e999f;">= </span><span style="color:#4271ae;">largest</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>number_list);
</span><span>    println!(</span><span style="color:#718c00;">&quot;The largest number is </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, result);
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> char_list </span><span style="color:#3e999f;">= </span><span>vec![</span><span style="color:#718c00;">&#39;y&#39;</span><span>, </span><span style="color:#718c00;">&#39;m&#39;</span><span>, </span><span style="color:#718c00;">&#39;a&#39;</span><span>, </span><span style="color:#718c00;">&#39;q&#39;</span><span>];
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> result </span><span style="color:#3e999f;">= </span><span style="color:#4271ae;">largest</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>char_list);
</span><span>    println!(</span><span style="color:#718c00;">&quot;The largest char is </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, result);
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/generic_largest.rs">generic_largest.rs</a>)</sub></p>
<h2 id="a-powerful-tool">A powerful tool</h2>
<p>There's a lot more that we can do with generics:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#c82829;">allow</span><span>(dead_code)]
</span><span>
</span><span style="color:#8959a8;">use </span><span>std::fmt::Debug;
</span><span>
</span><span style="color:#999999;">// Generic enums.
</span><span style="color:#8959a8;">enum </span><span>OurOption&lt;T&gt; {
</span><span>    </span><span style="color:#c99e00;">Some</span><span>(T),
</span><span>    </span><span style="color:#c99e00;">None</span><span>,
</span><span>}
</span><span>
</span><span style="color:#999999;">// Generic structs.
</span><span style="color:#8959a8;">struct </span><span>Tuple2&lt;T, U&gt; {
</span><span>    </span><span style="color:#c82829;">x</span><span>: T,
</span><span>    </span><span style="color:#c82829;">y</span><span>: U,
</span><span>}
</span><span>
</span><span style="color:#999999;">// Generic implementation.
</span><span style="color:#8959a8;">impl</span><span>&lt;T, U&gt; Tuple2&lt;T, U&gt; {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">new</span><span>(</span><span style="color:#f5871f;">x</span><span>: T, </span><span style="color:#f5871f;">y</span><span>: U) -&gt; </span><span style="color:#8959a8;">Self </span><span>{
</span><span>        </span><span style="color:#8959a8;">Self </span><span>{ x, y }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Pair&lt;T&gt; {
</span><span>    </span><span style="color:#c82829;">x</span><span>: T,
</span><span>    </span><span style="color:#c82829;">y</span><span>: T,
</span><span>}
</span><span>
</span><span style="color:#999999;">// Conditional implementation.
</span><span style="color:#8959a8;">impl</span><span>&lt;T: </span><span style="color:#c99e00;">PartialOrd </span><span style="color:#3e999f;">+ </span><span style="color:#c99e00;">Copy</span><span>&gt; Pair&lt;T&gt; {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">largest</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; T {
</span><span>        </span><span style="color:#8959a8;">if </span><span style="color:#c82829;">self</span><span>.x </span><span style="color:#3e999f;">&gt; </span><span style="color:#c82829;">self</span><span>.y {
</span><span>            </span><span style="color:#c82829;">self</span><span>.x
</span><span>        } </span><span style="color:#8959a8;">else </span><span>{
</span><span>            </span><span style="color:#c82829;">self</span><span>.y
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#999999;">// Alternative syntax.
</span><span style="color:#8959a8;">impl</span><span>&lt;T&gt; Pair&lt;T&gt;
</span><span style="color:#8959a8;">where
</span><span>    T: PartialOrd + Copy,
</span><span>{
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">smallest</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; T {
</span><span>        </span><span style="color:#8959a8;">if </span><span style="color:#c82829;">self</span><span>.x </span><span style="color:#3e999f;">&lt; </span><span style="color:#c82829;">self</span><span>.y {
</span><span>            </span><span style="color:#c82829;">self</span><span>.x
</span><span>        } </span><span style="color:#8959a8;">else </span><span>{
</span><span>            </span><span style="color:#c82829;">self</span><span>.y
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#999999;">// The information about the concrete underlying type is preserved.
</span><span style="color:#999999;">// If I call it with a `String`, then I get back a `String`.
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">cloning_machine</span><span>&lt;T: </span><span style="color:#c99e00;">Clone </span><span style="color:#3e999f;">+</span><span> Debug&gt;(</span><span style="color:#f5871f;">item</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>T) -&gt; T {
</span><span>    item.</span><span style="color:#4271ae;">clone</span><span>()
</span><span>}
</span><span>
</span><span style="color:#999999;">// The information about the concrete underlying type is erased.
</span><span style="color:#999999;">// We can only either format or clone the result.
</span><span style="color:#999999;">// If I call it with a `String`, then I&#39;ll only know that the return type
</span><span style="color:#999999;">// implements `Clone + Debug`.
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">erasing_cloning_machine2</span><span>&lt;T: </span><span style="color:#c99e00;">Clone </span><span style="color:#3e999f;">+</span><span> Debug&gt;(</span><span style="color:#f5871f;">item</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>T) -&gt; impl Clone </span><span style="color:#3e999f;">+</span><span> Debug {
</span><span>    item.</span><span style="color:#4271ae;">clone</span><span>()
</span><span>}
</span><span>
</span><span style="color:#999999;">// The returned type behaves exactly the same as above (it&#39;s the same type, after all)
</span><span style="color:#999999;">// and the function has the same requirements for the `item` argument.
</span><span style="color:#999999;">// But inside the implementation of the function, we can&#39;t use `T` (it&#39;s not defined anywhere).
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">erasing_cloning_machine1</span><span>(</span><span style="color:#f5871f;">item</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>(</span><span style="color:#f5871f;">impl Clone</span><span> + </span><span style="color:#f5871f;">Debug</span><span>)) -&gt; impl Clone </span><span style="color:#3e999f;">+</span><span> Debug {
</span><span>    item.</span><span style="color:#4271ae;">clone</span><span>()
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> _opt </span><span style="color:#3e999f;">= </span><span>OurOption::Some(</span><span style="color:#f5871f;">10</span><span>);
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> _p1 </span><span style="color:#3e999f;">=</span><span> Tuple2 { x: </span><span style="color:#f5871f;">5</span><span>, y: </span><span style="color:#f5871f;">10 </span><span>};
</span><span>    </span><span style="color:#8959a8;">let</span><span> _p2 </span><span style="color:#3e999f;">= </span><span>Tuple2::new(</span><span style="color:#f5871f;">1</span><span>, </span><span style="color:#f5871f;">2.5</span><span>);
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> arr </span><span style="color:#3e999f;">= </span><span>[</span><span style="color:#f5871f;">1</span><span>, </span><span style="color:#f5871f;">2</span><span>, </span><span style="color:#f5871f;">3</span><span>];
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> arr2 </span><span style="color:#3e999f;">= </span><span style="color:#4271ae;">cloning_machine</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>arr);
</span><span>    </span><span style="color:#8959a8;">let</span><span> _x </span><span style="color:#3e999f;">=</span><span> arr2[</span><span style="color:#f5871f;">0</span><span>]; </span><span style="color:#999999;">// This compiles, because `cloning_machine` preserves the type.
</span><span>    println!(</span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{:?}</span><span style="color:#718c00;">&quot;</span><span>, arr2);
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> arr3 </span><span style="color:#3e999f;">= </span><span style="color:#4271ae;">erasing_cloning_machine1</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>arr);
</span><span>    </span><span style="color:#999999;">// arr3[0]; // won&#39;t compile: cannot index into a value of type `impl std::clone::Clone + std::fmt::Debug`
</span><span>    println!(</span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{:?}</span><span style="color:#718c00;">&quot;</span><span>, arr3);
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> arr4 </span><span style="color:#3e999f;">= </span><span style="color:#4271ae;">erasing_cloning_machine2</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>arr);
</span><span>    </span><span style="color:#999999;">// arr4[0]; // won&#39;t compile: cannot index into a value of type `impl std::clone::Clone + std::fmt::Debug`
</span><span>    println!(</span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{:?}</span><span style="color:#718c00;">&quot;</span><span>, arr4);
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/generics.rs">generics.rs</a>)</sub></p>
<p>An example where we can specify which generic trait implementation we want to call:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">use </span><span>std::fmt::{Display, Formatter};
</span><span>
</span><span style="color:#8959a8;">trait </span><span>DefaultishablyPrintable&lt;T&gt; {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">defaultish_print</span><span>()
</span><span>    </span><span style="color:#8959a8;">where
</span><span>        T: Display + Default,
</span><span>    {
</span><span>        println!(</span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, T::default())
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Foo;
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Bar;
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>Bar {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        f.</span><span style="color:#4271ae;">write_str</span><span>(</span><span style="color:#718c00;">&quot;this is a bar&quot;</span><span>)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Default </span><span style="color:#8959a8;">for </span><span>Bar {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">default</span><span>() -&gt; </span><span style="color:#8959a8;">Self </span><span>{
</span><span>        Bar </span><span style="color:#999999;">// Well, we have no other choice.
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>DefaultishablyPrintable&lt;</span><span style="color:#8959a8;">i32</span><span>&gt; </span><span style="color:#8959a8;">for </span><span>Foo {}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>DefaultishablyPrintable&lt;Bar&gt; </span><span style="color:#8959a8;">for </span><span>Foo {}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#999999;">// By typing `Foo as DefaultishablyPrintable&lt;i32&gt;`,
</span><span>    </span><span style="color:#999999;">// we tell the compiler to treat this `Foo` struct as
</span><span>    </span><span style="color:#999999;">// only a `DefaultishablyPrintable&lt;i32&gt;` trait.
</span><span>    </span><span style="color:#3e999f;">&lt;</span><span>Foo </span><span style="color:#3e999f;">as </span><span>DefaultishablyPrintable&lt;</span><span style="color:#8959a8;">i32</span><span>&gt;</span><span style="color:#3e999f;">&gt;</span><span>::defaultish_print();
</span><span>    &lt;Foo </span><span style="color:#3e999f;">as </span><span>DefaultishablyPrintable&lt;Bar&gt;&gt;::defaultish_print();
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/generics_fun.rs">generics_fun.rs</a>)</sub></p>
<h2 id="static-vs-dynamic-dispatch">Static vs dynamic dispatch</h2>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">trait </span><span>Speak {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">speak</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;static str</span><span>;
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Dog;
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Speak </span><span style="color:#8959a8;">for </span><span>Dog {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">speak</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;static str </span><span>{
</span><span>        </span><span style="color:#718c00;">&quot;Hau hau&quot; </span><span style="color:#999999;">// It&#39;s a Polish dog!
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Human;
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Speak </span><span style="color:#8959a8;">for </span><span>Human {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">speak</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;static str </span><span>{
</span><span>        </span><span style="color:#718c00;">&quot;Hello world&quot;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#999999;">// It works like templates in C++.
</span><span style="color:#999999;">// A different function will be generated for each T during compilation.
</span><span style="color:#999999;">// This process is called &quot;monomorphization&quot;.
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">static_dispatch</span><span>&lt;T: Speak&gt;(</span><span style="color:#f5871f;">speaking</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>T) {
</span><span>    println!(</span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">!&quot;</span><span>, speaking.</span><span style="color:#4271ae;">speak</span><span>());
</span><span>}
</span><span>
</span><span style="color:#999999;">// Only one copy of that function will exist in the compiled binary.
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">dynamic_dispatch</span><span>(</span><span style="color:#f5871f;">speaking</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>dyn Speak) {
</span><span>    println!(</span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">!&quot;</span><span>, speaking.</span><span style="color:#4271ae;">speak</span><span>());
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> dog </span><span style="color:#3e999f;">=</span><span> Dog;
</span><span>    </span><span style="color:#8959a8;">let</span><span> human </span><span style="color:#3e999f;">=</span><span> Human;
</span><span>
</span><span>    </span><span style="color:#4271ae;">static_dispatch</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>dog);
</span><span>    </span><span style="color:#4271ae;">static_dispatch</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>human);
</span><span>
</span><span>    </span><span style="color:#4271ae;">dynamic_dispatch</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>dog);
</span><span>    </span><span style="color:#4271ae;">dynamic_dispatch</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>human);
</span><span>
</span><span>    </span><span style="color:#999999;">// The observable behavior is identical.
</span><span>    </span><span style="color:#999999;">// Static dispatch in general is a bit faster,
</span><span>    </span><span style="color:#999999;">// because there is no need to perform a &quot;vtable lookup&quot;.
</span><span>    </span><span style="color:#999999;">// But it can also result in bigger binary sizes.
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/static_dynamic_dispatch.rs">static_dynamic_dispatch.rs</a>)</sub></p>
<h1 id="lifetimes">Lifetimes</h1>
<p>Let's go into a completely different topic now.
Going back to the lesson about ownership, if we try to compile the following code:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span>{
</span><span>    </span><span style="color:#8959a8;">let</span><span> r;
</span><span>
</span><span>    {
</span><span>        </span><span style="color:#8959a8;">let</span><span> x </span><span style="color:#3e999f;">= </span><span style="color:#f5871f;">5</span><span>;
</span><span>        r </span><span style="color:#3e999f;">= &amp;</span><span>x;
</span><span>    }
</span><span>
</span><span>    println!(</span><span style="color:#718c00;">&quot;r: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, r);
</span><span>}
</span></code></pre>
<p>we should expect to get an error:</p>
<pre style="background-color:#ffffff;color:#4d4d4c;"><code><span>error[E0597]: `x` does not live long enough
</span><span>  --&gt; src/main.rs:7:17
</span><span>   |
</span><span>7  |             r = &amp;x;
</span><span>   |                 ^^ borrowed value does not live long enough
</span><span>8  |         }
</span><span>   |         - `x` dropped here while still borrowed
</span><span>9  |
</span><span>10 |         println!(&quot;r: {}&quot;, r);
</span><span>   |                           - borrow later used here
</span></code></pre>
<p>Courtesy of the borrow checker, we didn't end up with a dangling reference. But what exactly is happening behind the scenes? Rust introduces a concept of annotated lifetimes, where the lifetime of each value is being marked and tracked by the checker. Let's look at some examples:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span>{
</span><span>    </span><span style="color:#8959a8;">let</span><span> r;                  </span><span style="color:#999999;">// ---------+-- &#39;a
</span><span>                            </span><span style="color:#999999;">//          |
</span><span>    {                       </span><span style="color:#999999;">//          |
</span><span>        </span><span style="color:#8959a8;">let</span><span> x </span><span style="color:#3e999f;">= </span><span style="color:#f5871f;">5</span><span>;          </span><span style="color:#999999;">// -+-- &#39;b  |
</span><span>        r </span><span style="color:#3e999f;">= &amp;</span><span>x;             </span><span style="color:#999999;">//  |       |
</span><span>    }                       </span><span style="color:#999999;">// -+       |
</span><span>                            </span><span style="color:#999999;">//          |
</span><span>    println!(</span><span style="color:#718c00;">&quot;r: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, r);   </span><span style="color:#999999;">//          |
</span><span>}                           </span><span style="color:#999999;">// ---------+
</span></code></pre>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span>{
</span><span>    </span><span style="color:#8959a8;">let</span><span> x </span><span style="color:#3e999f;">= </span><span style="color:#f5871f;">5</span><span>;              </span><span style="color:#999999;">// ----------+-- &#39;b
</span><span>                            </span><span style="color:#999999;">//           |
</span><span>    </span><span style="color:#8959a8;">let</span><span> r </span><span style="color:#3e999f;">= &amp;</span><span>x;             </span><span style="color:#999999;">// --+-- &#39;a  |
</span><span>                            </span><span style="color:#999999;">//   |       |
</span><span>    println!(</span><span style="color:#718c00;">&quot;r: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, r);   </span><span style="color:#999999;">//   |       |
</span><span>                            </span><span style="color:#999999;">// --+       |
</span><span>}                           </span><span style="color:#999999;">// ----------+
</span></code></pre>
<h2 id="annotations">Annotations</h2>
<p>Let's consider the following code finding the longer out of two strings:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">longest</span><span>(</span><span style="color:#f5871f;">x</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">str</span><span>, </span><span style="color:#f5871f;">y</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">str</span><span>) -&gt; </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">str </span><span>{
</span><span>    </span><span style="color:#8959a8;">if</span><span> x.</span><span style="color:#4271ae;">len</span><span>() </span><span style="color:#3e999f;">&gt;</span><span> y.</span><span style="color:#4271ae;">len</span><span>() {
</span><span>        x
</span><span>    } </span><span style="color:#8959a8;">else </span><span>{
</span><span>        y
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> string1 </span><span style="color:#3e999f;">= </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;abcd&quot;</span><span>);
</span><span>    </span><span style="color:#8959a8;">let</span><span> string2 </span><span style="color:#3e999f;">= </span><span style="color:#718c00;">&quot;xyz&quot;</span><span>;
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> result </span><span style="color:#3e999f;">= </span><span style="color:#4271ae;">longest</span><span>(string1.</span><span style="color:#4271ae;">as_str</span><span>(), string2);
</span><span>    println!(</span><span style="color:#718c00;">&quot;The longest string is </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, result);
</span><span>}
</span></code></pre>
<p>If we try to compile this, we will get an error:</p>
<pre style="background-color:#ffffff;color:#4d4d4c;"><code><span>error[E0106]: missing lifetime specifier
</span><span> --&gt; src/main.rs:9:33
</span><span>  |
</span><span>9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</span><span>  |               ----     ----     ^ expected named lifetime parameter
</span><span>  |
</span><span>  = help: this function&#39;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
</span><span>help: consider introducing a named lifetime parameter
</span><span>  |
</span><span>9 | fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {
</span><span>  |           ++++     ++          ++          ++
</span></code></pre>
<p>This is because Rust doesn't know which of the two provided strings (<code>x</code> or <code>y</code>) will be returned from the function. And because they potentially have different lifetimes, the lifetime of what we are returning remains unclear to the compiler - it needs our help.</p>
<p>Rust provides syntax for specifying lifetimes. The lifetime parameter name from the example (<code>a</code>) doesn't have any concrete meaning - it's just an arbitrary name for this one lifetime.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">i32        </span><span style="color:#999999;">// a reference
</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a i32     </span><span style="color:#999999;">// a reference with an explicit lifetime
</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a mut i32 </span><span style="color:#999999;">// a mutable reference with an explicit lifetime
</span></code></pre>
<p>So, knowing this, let's address the compiler's demands.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">longest</span><span>&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;(</span><span style="color:#f5871f;">x</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a str</span><span>, </span><span style="color:#f5871f;">y</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a str</span><span>) -&gt; </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a str </span><span>{
</span><span>    </span><span style="color:#8959a8;">if</span><span> x.</span><span style="color:#4271ae;">len</span><span>() </span><span style="color:#3e999f;">&gt;</span><span> y.</span><span style="color:#4271ae;">len</span><span>() {
</span><span>        x
</span><span>    } </span><span style="color:#8959a8;">else </span><span>{
</span><span>        y
</span><span>    }
</span><span>}
</span></code></pre>
<p>When working with lifetimes, our work will usually revolve around specifying relationships between lifetimes of different values so that the compiler can successfully reason about the program's safety. In the context of the example above, this signature means that both of the function's arguments and its output will live at least as long as lifetime <code>'a</code>. In practice, this means that the output's lifetime will be equal to the smaller of the two inputs' lifetimes.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">longest</span><span>&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;(</span><span style="color:#f5871f;">first</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a str</span><span>, </span><span style="color:#f5871f;">second</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a str</span><span>) -&gt; </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a str </span><span>{
</span><span>    </span><span style="color:#8959a8;">if</span><span> first.</span><span style="color:#4271ae;">len</span><span>() </span><span style="color:#3e999f;">&gt;</span><span> second.</span><span style="color:#4271ae;">len</span><span>() {
</span><span>        first
</span><span>    } </span><span style="color:#8959a8;">else </span><span>{
</span><span>        second
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> string1 </span><span style="color:#3e999f;">= </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;long string is long&quot;</span><span>);
</span><span>
</span><span>    {
</span><span>        </span><span style="color:#8959a8;">let</span><span> string2 </span><span style="color:#3e999f;">= </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;xyz&quot;</span><span>);
</span><span>        </span><span style="color:#8959a8;">let</span><span> result </span><span style="color:#3e999f;">= </span><span style="color:#4271ae;">longest</span><span>(string1.</span><span style="color:#4271ae;">as_str</span><span>(), string2.</span><span style="color:#4271ae;">as_str</span><span>());
</span><span>        println!(</span><span style="color:#718c00;">&quot;The longest string is </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, result);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#999999;">// This doesn&#39;t compile - incorrect lifetimes
</span><span>    </span><span style="color:#999999;">//
</span><span>    </span><span style="color:#999999;">// let string1 = String::from(&quot;long string is long&quot;);
</span><span>    </span><span style="color:#999999;">// let result;
</span><span>    </span><span style="color:#999999;">// {
</span><span>    </span><span style="color:#999999;">//     let string2 = String::from(&quot;xyz&quot;);
</span><span>    </span><span style="color:#999999;">//     result = longest(string1.as_str(), string2.as_str());
</span><span>    </span><span style="color:#999999;">// }
</span><span>    </span><span style="color:#999999;">// println!(&quot;The longest string is {}&quot;, result);
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/lifetimes_basic.rs">lifetimes_basic.rs</a>)</sub></p>
<p>Trying to compile the second variant displeases the compiler (just like we hoped).</p>
<pre style="background-color:#ffffff;color:#4d4d4c;"><code><span>error[E0597]: `string2` does not live long enough
</span><span> --&gt; src/main.rs:6:44
</span><span>  |
</span><span>6 |         result = longest(string1.as_str(), string2.as_str());
</span><span>  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
</span><span>7 |     }
</span><span>  |     - `string2` dropped here while still borrowed
</span><span>8 |     println!(&quot;The longest string is {}&quot;, result);
</span><span>  |                                          ------ borrow later used here
</span></code></pre>
<h2 id="lifetime-elision">Lifetime elision</h2>
<p>We now know how to explicitly write lifetime parameters, but you might recall that we don't always have to do that. Indeed, Rust will first try to figure out the lifetimes itself, applying a set of predefined rules. We call this <em>lifetime elision</em>.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">first_two</span><span>(</span><span style="color:#f5871f;">seq</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>[</span><span style="color:#8959a8;">u32</span><span>]) -&gt; </span><span style="color:#3e999f;">&amp;</span><span>[</span><span style="color:#8959a8;">u32</span><span>] {
</span><span>    </span><span style="color:#8959a8;">if</span><span> seq.</span><span style="color:#4271ae;">len</span><span>() </span><span style="color:#3e999f;">&lt; </span><span style="color:#f5871f;">2 </span><span>{
</span><span>        seq
</span><span>    } </span><span style="color:#8959a8;">else </span><span>{
</span><span>        </span><span style="color:#3e999f;">&amp;</span><span>seq[</span><span style="color:#3e999f;">..</span><span style="color:#f5871f;">2</span><span>]
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> seq </span><span style="color:#3e999f;">= </span><span>[</span><span style="color:#f5871f;">1</span><span>, </span><span style="color:#f5871f;">2</span><span>, </span><span style="color:#f5871f;">3</span><span>, </span><span style="color:#f5871f;">4</span><span>];
</span><span>
</span><span>    println!(
</span><span>        </span><span style="color:#718c00;">&quot;First two elements of the sequence: </span><span style="color:#666969;">{:?}</span><span style="color:#718c00;">&quot;</span><span>,
</span><span>        </span><span style="color:#4271ae;">first_two</span><span>(</span><span style="color:#3e999f;">&amp;</span><span>seq[</span><span style="color:#3e999f;">..</span><span>])
</span><span>    );
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/lifetimes_elision.rs">lifetimes_elision.rs</a>)</sub></p>
<p>The above works, even though we didn't specify any lifetime parameters at all. The reason lies in the rules we mentioned, which are as follows (where input lifetimes are lifetimes on parameters and output lifetimes are lifetimes on return values):</p>
<ul>
<li>
<p>Each parameter that is a reference gets its own lifetime parameter.</p>
</li>
<li>
<p>If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters.</p>
</li>
<li>
<p>If there are multiple input lifetime parameters, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code>, the lifetime of <code>self</code> is assigned to all output lifetime parameters.</p>
</li>
</ul>
<p>Let's try to understand how the compiler inferred the lifetimes of our <code>first_two</code> functions. We start with the following signature:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">first_two</span><span>(</span><span style="color:#f5871f;">seq</span><span>: </span><span style="color:#3e999f;">&amp;</span><span>[</span><span style="color:#8959a8;">u32</span><span>]) -&gt; </span><span style="color:#3e999f;">&amp;</span><span>[</span><span style="color:#8959a8;">u32</span><span>] {
</span></code></pre>
<p>Then, we apply the first rule:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">first_two</span><span>&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;(</span><span style="color:#f5871f;">seq</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a</span><span> [</span><span style="color:#8959a8;">u32</span><span>]) -&gt; </span><span style="color:#3e999f;">&amp;</span><span>[</span><span style="color:#8959a8;">u32</span><span>] {
</span></code></pre>
<p>Next, we check the second rule. It applies here as well.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">first_two</span><span>&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;(</span><span style="color:#f5871f;">seq</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a</span><span> [</span><span style="color:#8959a8;">u32</span><span>]) -&gt; </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a </span><span>[</span><span style="color:#8959a8;">u32</span><span>] {
</span></code></pre>
<p>With that, we arrive at a state where all lifetimes are specified.</p>
<h2 id="static-lifetime">Static lifetime</h2>
<p>There exists one special lifetime called <code>'static</code>, which means that a reference can live for the entire duration of the program. All string literals are annotated with this lifetime as they are stored directly in the program's binary. Full type annotation of a string literal in Rust is therefore as follows:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8959a8;">let</span><span> s: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;static str </span><span style="color:#3e999f;">= </span><span style="color:#718c00;">&quot;I have a static lifetime.&quot;</span><span>;
</span></code></pre>
<h1 id="trait-lifetimes-a-challenging-tandem">Trait + lifetimes - a challenging tandem</h1>
<p>Let's go back to our <code>basic_trait.rs</code> example. The <code>Summary</code> trait was really wasteful: it always allocated the <code>String</code>s on heap, even though we only needed to display the formatted string, and we could do that without allocations. How? By using <code>Display</code> trait, of course.</p>
<p>The simplest possible optimisation would be like this:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#c82829;">allow</span><span>(dead_code)]
</span><span>
</span><span style="color:#8959a8;">use </span><span>std::fmt::Display;
</span><span>
</span><span style="color:#8959a8;">struct </span><span>NewsArticle {
</span><span>    </span><span style="color:#c82829;">headline</span><span>: String,
</span><span>    </span><span style="color:#c82829;">location</span><span>: String,
</span><span>    </span><span style="color:#c82829;">author</span><span>: String,
</span><span>    </span><span style="color:#c82829;">content</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>NewsArticle {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        write!(
</span><span>            f,
</span><span>            </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">, by </span><span style="color:#666969;">{}</span><span style="color:#718c00;"> (</span><span style="color:#666969;">{}</span><span style="color:#718c00;">)&quot;</span><span>,
</span><span>            </span><span style="color:#c82829;">self</span><span>.headline, </span><span style="color:#c82829;">self</span><span>.author, </span><span style="color:#c82829;">self</span><span>.location
</span><span>        )
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Tweet {
</span><span>    </span><span style="color:#c82829;">username</span><span>: String,
</span><span>    </span><span style="color:#c82829;">content</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>Tweet {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        write!(f, </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, </span><span style="color:#c82829;">self</span><span>.username, </span><span style="color:#c82829;">self</span><span>.content)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> tweet </span><span style="color:#3e999f;">=</span><span> Tweet {
</span><span>        username: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;horse_ebooks&quot;</span><span>),
</span><span>        content: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;of course, as you probably already know, people&quot;</span><span>),
</span><span>    };
</span><span>
</span><span>    println!(</span><span style="color:#718c00;">&quot;1 new tweet: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, tweet);
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/basic_trait_display.rs">basic_trait_display.rs</a>)</sub></p>
<p>This eliminates the heap allocations, but there's another catch. What if <code>NewsArticle</code> already had another (non-summarizing) <code>Display</code> implementation? We would end up in a double-trait-implementation conflict, which is a compile-time error.</p>
<p>We can solve the one-type-one-trait-impl problem by introducing another type just for summarizing. The first attempt could be to use generics in traits:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#c82829;">allow</span><span>(dead_code)]
</span><span>
</span><span style="color:#8959a8;">use </span><span>std::fmt::Display;
</span><span>
</span><span style="color:#8959a8;">trait </span><span>Summary&lt;&#39;a, Summarizer: Display&gt; {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a </span><span style="color:#f5871f;">self</span><span>) -&gt; Summarizer;
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>NewsArticle {
</span><span>    </span><span style="color:#c82829;">headline</span><span>: String,
</span><span>    </span><span style="color:#c82829;">location</span><span>: String,
</span><span>    </span><span style="color:#c82829;">author</span><span>: String,
</span><span>    </span><span style="color:#c82829;">content</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>NewsArticle {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        writeln!(
</span><span>            f,
</span><span>            </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">, by </span><span style="color:#666969;">{}</span><span style="color:#718c00;"> (</span><span style="color:#666969;">{}</span><span style="color:#718c00;">)&quot;</span><span>,
</span><span>            </span><span style="color:#c82829;">self</span><span>.headline, </span><span style="color:#c82829;">self</span><span>.author, </span><span style="color:#c82829;">self</span><span>.location
</span><span>        )</span><span style="color:#3e999f;">?</span><span>;
</span><span>        f.</span><span style="color:#4271ae;">write_str</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#c82829;">self</span><span>.content)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>NewsArticleSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a</span><span> NewsArticle);
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>NewsArticleSummarizer&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt; {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        </span><span style="color:#8959a8;">let</span><span> article </span><span style="color:#3e999f;">= </span><span style="color:#c82829;">self</span><span>.</span><span style="color:#f5871f;">0</span><span>;
</span><span>        write!(
</span><span>            f,
</span><span>            </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">, by </span><span style="color:#666969;">{}</span><span style="color:#718c00;"> (</span><span style="color:#666969;">{}</span><span style="color:#718c00;">)&quot;</span><span>,
</span><span>            article.headline, article.author, article.location
</span><span>        )
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl</span><span>&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt; Summary&lt;</span><span style="color:#8959a8;">&#39;a</span><span>, NewsArticleSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;&gt; </span><span style="color:#8959a8;">for </span><span>NewsArticle {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a </span><span style="color:#f5871f;">self</span><span>) -&gt; NewsArticleSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt; {
</span><span>        NewsArticleSummarizer(</span><span style="color:#c82829;">self</span><span>)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Tweet {
</span><span>    </span><span style="color:#c82829;">username</span><span>: String,
</span><span>    </span><span style="color:#c82829;">content</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>TweetSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a</span><span> Tweet);
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>TweetSummarizer&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt; {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        </span><span style="color:#8959a8;">let</span><span> tweet </span><span style="color:#3e999f;">= </span><span style="color:#c82829;">self</span><span>.</span><span style="color:#f5871f;">0</span><span>;
</span><span>        write!(f, </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, tweet.username, tweet.content)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl</span><span>&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt; Summary&lt;</span><span style="color:#8959a8;">&#39;a</span><span>, TweetSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;&gt; </span><span style="color:#8959a8;">for </span><span>Tweet {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a </span><span style="color:#f5871f;">self</span><span>) -&gt; TweetSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt; {
</span><span>        TweetSummarizer(</span><span style="color:#c82829;">self</span><span>)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl</span><span>&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt; Summary&lt;</span><span style="color:#8959a8;">&#39;a</span><span>, NewsArticleSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;&gt; </span><span style="color:#8959a8;">for </span><span>Tweet {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a </span><span style="color:#f5871f;">self</span><span>) -&gt; NewsArticleSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt; {
</span><span>        unimplemented!(</span><span style="color:#718c00;">&quot;This is only to make code type-check and compile.&quot;</span><span>);
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> empty_article </span><span style="color:#3e999f;">=</span><span> NewsArticle {
</span><span>        headline: </span><span style="color:#718c00;">&quot;&quot;</span><span>.</span><span style="color:#4271ae;">into</span><span>(),
</span><span>        location: </span><span style="color:#c99e00;">String</span><span>::new(),
</span><span>        author: </span><span style="color:#c99e00;">String</span><span>::default(),
</span><span>        content: </span><span style="color:#c99e00;">Default</span><span>::default(),
</span><span>    };
</span><span>    println!(</span><span style="color:#718c00;">&quot;1 new article: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, empty_article.</span><span style="color:#4271ae;">summarize</span><span>());
</span><span>
</span><span>    </span><span style="color:#8959a8;">let</span><span> tweet </span><span style="color:#3e999f;">=</span><span> Tweet {
</span><span>        username: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;horse_ebooks&quot;</span><span>),
</span><span>        content: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;of course, as you probably already know, people&quot;</span><span>),
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#999999;">// Compile error: `type annotations needed; multiple `impl`s satisfying `Tweet: Summary&lt;&#39;_, _&gt;` found`
</span><span>    </span><span style="color:#999999;">// println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</span><span>    println!(
</span><span>        </span><span style="color:#718c00;">&quot;1 new tweet: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>,
</span><span>        &lt;Tweet </span><span style="color:#3e999f;">as </span><span>Summary&lt;&#39;</span><span style="color:#3e999f;">_</span><span>, TweetSummarizer&gt;&gt;::summarize(</span><span style="color:#3e999f;">&amp;</span><span>tweet)
</span><span>    );
</span><span>    println!(
</span><span>        </span><span style="color:#718c00;">&quot;1 new tweet: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>,
</span><span>        &lt;Tweet </span><span style="color:#3e999f;">as </span><span>Summary&lt;&#39;</span><span style="color:#3e999f;">_</span><span>, NewsArticleSummarizer&gt;&gt;::summarize(</span><span style="color:#3e999f;">&amp;</span><span>tweet)
</span><span>    );
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/trait_generic_type.rs">trait_generic_type.rs</a>)</sub></p>
<p>The problem here is that nothing hinders us from implement the trait (with various type parameters) for the same type, which leads to awkward ambiguity when calling the trait's methods (see <code>main</code> fn).</p>
<p>The use of generic types in <code>Summary</code> trait makes it semantics like this:</p>
<blockquote>
<p>A type can be summarized with any type supporting it.</p>
</blockquote>
<p>When we want the trait to require exactly one possible generic implementation for a given type, we can leverage <em>associated types</em>. Example here:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#c82829;">allow</span><span>(dead_code)]
</span><span>
</span><span style="color:#8959a8;">use </span><span>std::fmt::Display;
</span><span>
</span><span style="color:#8959a8;">trait </span><span>Summary&lt;&#39;a&gt; {
</span><span>    </span><span style="color:#8959a8;">type </span><span>Summarizer: Display;
</span><span>
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a </span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#8959a8;">Self::</span><span>Summarizer;
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>NewsArticle {
</span><span>    </span><span style="color:#c82829;">headline</span><span>: String,
</span><span>    </span><span style="color:#c82829;">location</span><span>: String,
</span><span>    </span><span style="color:#c82829;">author</span><span>: String,
</span><span>    </span><span style="color:#c82829;">content</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>NewsArticle {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        writeln!(
</span><span>            f,
</span><span>            </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">, by </span><span style="color:#666969;">{}</span><span style="color:#718c00;"> (</span><span style="color:#666969;">{}</span><span style="color:#718c00;">)&quot;</span><span>,
</span><span>            </span><span style="color:#c82829;">self</span><span>.headline, </span><span style="color:#c82829;">self</span><span>.author, </span><span style="color:#c82829;">self</span><span>.location
</span><span>        )</span><span style="color:#3e999f;">?</span><span>;
</span><span>        f.</span><span style="color:#4271ae;">write_str</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#c82829;">self</span><span>.content)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>NewsArticleSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a</span><span> NewsArticle);
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>NewsArticleSummarizer&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt; {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        </span><span style="color:#8959a8;">let</span><span> article </span><span style="color:#3e999f;">= </span><span style="color:#c82829;">self</span><span>.</span><span style="color:#f5871f;">0</span><span>;
</span><span>        write!(
</span><span>            f,
</span><span>            </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">, by </span><span style="color:#666969;">{}</span><span style="color:#718c00;"> (</span><span style="color:#666969;">{}</span><span style="color:#718c00;">)&quot;</span><span>,
</span><span>            article.headline, article.author, article.location
</span><span>        )
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl</span><span>&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt; Summary&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt; </span><span style="color:#8959a8;">for </span><span>NewsArticle {
</span><span>    </span><span style="color:#8959a8;">type </span><span>Summarizer </span><span style="color:#3e999f;">= </span><span>NewsArticleSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;;
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a </span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#8959a8;">Self::</span><span>Summarizer {
</span><span>        NewsArticleSummarizer(</span><span style="color:#c82829;">self</span><span>)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Tweet {
</span><span>    </span><span style="color:#c82829;">username</span><span>: String,
</span><span>    </span><span style="color:#c82829;">content</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>TweetSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a</span><span> Tweet);
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>TweetSummarizer&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt; {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        </span><span style="color:#8959a8;">let</span><span> tweet </span><span style="color:#3e999f;">= </span><span style="color:#c82829;">self</span><span>.</span><span style="color:#f5871f;">0</span><span>;
</span><span>        write!(f, </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, tweet.username, tweet.content)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl</span><span>&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt; Summary&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt; </span><span style="color:#8959a8;">for </span><span>Tweet {
</span><span>    </span><span style="color:#8959a8;">type </span><span>Summarizer </span><span style="color:#3e999f;">= </span><span>TweetSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;;
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a </span><span style="color:#f5871f;">self</span><span>) -&gt; </span><span style="color:#8959a8;">Self::</span><span>Summarizer {
</span><span>        TweetSummarizer(</span><span style="color:#c82829;">self</span><span>)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> tweet </span><span style="color:#3e999f;">=</span><span> Tweet {
</span><span>        username: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;horse_ebooks&quot;</span><span>),
</span><span>        content: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;of course, as you probably already know, people&quot;</span><span>),
</span><span>    };
</span><span>
</span><span>    println!(</span><span style="color:#718c00;">&quot;1 new tweet: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, tweet.</span><span style="color:#4271ae;">summarize</span><span>());
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/trait_associated_type.rs">trait_associated_type.rs</a>)</sub></p>
<p>The use of associated types in Summary trait makes it semantics like this:</p>
<blockquote>
<p>A type can be summarized with at most one specific type.</p>
</blockquote>
<p>Yet another approach (arguably, the cleanest one) would be to use the <code>impl trait</code> syntax in a trait (quite recently stabilized!).
Example:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#c82829;">allow</span><span>(dead_code)]
</span><span>
</span><span style="color:#8959a8;">use </span><span>std::fmt::Display;
</span><span>
</span><span style="color:#8959a8;">trait </span><span>Summary {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; impl Display;
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>NewsArticle {
</span><span>    </span><span style="color:#c82829;">headline</span><span>: String,
</span><span>    </span><span style="color:#c82829;">location</span><span>: String,
</span><span>    </span><span style="color:#c82829;">author</span><span>: String,
</span><span>    </span><span style="color:#c82829;">content</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>NewsArticle {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        writeln!(
</span><span>            f,
</span><span>            </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">, by </span><span style="color:#666969;">{}</span><span style="color:#718c00;"> (</span><span style="color:#666969;">{}</span><span style="color:#718c00;">)&quot;</span><span>,
</span><span>            </span><span style="color:#c82829;">self</span><span>.headline, </span><span style="color:#c82829;">self</span><span>.author, </span><span style="color:#c82829;">self</span><span>.location
</span><span>        )</span><span style="color:#3e999f;">?</span><span>;
</span><span>        f.</span><span style="color:#4271ae;">write_str</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#c82829;">self</span><span>.content)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>NewsArticleSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a</span><span> NewsArticle);
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>NewsArticleSummarizer&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt; {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>        </span><span style="color:#8959a8;">let</span><span> article </span><span style="color:#3e999f;">= </span><span style="color:#c82829;">self</span><span>.</span><span style="color:#f5871f;">0</span><span>;
</span><span>        write!(
</span><span>            f,
</span><span>            </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">, by </span><span style="color:#666969;">{}</span><span style="color:#718c00;"> (</span><span style="color:#666969;">{}</span><span style="color:#718c00;">)&quot;</span><span>,
</span><span>            article.headline, article.author, article.location
</span><span>        )
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Summary </span><span style="color:#8959a8;">for </span><span>NewsArticle {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; impl Display {
</span><span>        NewsArticleSummarizer(</span><span style="color:#c82829;">self</span><span>)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">struct </span><span>Tweet {
</span><span>    </span><span style="color:#c82829;">username</span><span>: String,
</span><span>    </span><span style="color:#c82829;">content</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8959a8;">impl </span><span>Summary </span><span style="color:#8959a8;">for </span><span>Tweet {
</span><span>    </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">summarize</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>) -&gt; impl Display {
</span><span>        </span><span style="color:#8959a8;">struct </span><span>TweetSummarizer&lt;</span><span style="color:#8959a8;">&#39;a</span><span>&gt;(</span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">&#39;a</span><span> Tweet);
</span><span>
</span><span>        </span><span style="color:#8959a8;">impl </span><span>Display </span><span style="color:#8959a8;">for </span><span>TweetSummarizer&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt; {
</span><span>            </span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">fmt</span><span>(</span><span style="color:#3e999f;">&amp;</span><span style="color:#f5871f;">self</span><span>, </span><span style="color:#f5871f;">f</span><span>: </span><span style="color:#3e999f;">&amp;</span><span style="color:#8959a8;">mut </span><span>std::fmt::Formatter&lt;&#39;</span><span style="color:#3e999f;">_</span><span>&gt;) -&gt; std::fmt::Result {
</span><span>                </span><span style="color:#8959a8;">let</span><span> tweet </span><span style="color:#3e999f;">= </span><span style="color:#c82829;">self</span><span>.</span><span style="color:#f5871f;">0</span><span>;
</span><span>                write!(f, </span><span style="color:#718c00;">&quot;</span><span style="color:#666969;">{}</span><span style="color:#718c00;">: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, tweet.username, tweet.content)
</span><span>            }
</span><span>        }
</span><span>
</span><span>        TweetSummarizer(</span><span style="color:#c82829;">self</span><span>)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8959a8;">fn </span><span style="color:#4271ae;">main</span><span>() {
</span><span>    </span><span style="color:#8959a8;">let</span><span> tweet </span><span style="color:#3e999f;">=</span><span> Tweet {
</span><span>        username: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;horse_ebooks&quot;</span><span>),
</span><span>        content: </span><span style="color:#c99e00;">String</span><span>::from(</span><span style="color:#718c00;">&quot;of course, as you probably already know, people&quot;</span><span>),
</span><span>    };
</span><span>
</span><span>    println!(</span><span style="color:#718c00;">&quot;1 new tweet: </span><span style="color:#666969;">{}</span><span style="color:#718c00;">&quot;</span><span>, tweet.</span><span style="color:#4271ae;">summarize</span><span>());
</span><span>}
</span><span>
</span></code></pre>
<p><sub>(Download the source code for this example: <a href="https://mimuw-jnp2-rust.github.io/lessons/05-types-reasoning/impl_trait.rs">impl_trait.rs</a>)</sub></p>
<h1 id="obligatory-reading">Obligatory reading</h1>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/book/ch10-00-generics.html">The Book, chapter 10</a></p>
</li>
<li>
<p><a href="https://oswalt.dev/2021/06/polymorphism-in-rust/">Polymorphism in Rust</a></p>
</li>
</ul>
<h1 id="optional-reading">Optional reading</h1>
<ul>
<li><a href="https://blog.rust-lang.org/2024/10/17/Rust-1.82.0/#precise-capturing-use-syntax">Rust Blog - Precise capturing <code>use&lt;..&gt;</code> syntax</a></li>
</ul>
<h2 id="assignment-3-graded">Assignment 3 (graded)</h2>
<p><a href="https://classroom.github.com/a/XVoSKs94">Passage Pathing</a></p>
<p>Deadline: per-group.</p>


    </div>
  </div>

  <div class="prev-link">
    
    
  </div>

  <div class="next-link">
    
    
  </div>
</div>


  
  <script type="text/javascript" src="https://mimuw-jnp2-rust.github.io/elasticlunr.min.js"></script>
  <script type="text/javascript" src="https://mimuw-jnp2-rust.github.io/search_index.en.js"></script>
  
  <script type="text/javascript" src="https://mimuw-jnp2-rust.github.io/book.js"></script>

</body>

</html>
